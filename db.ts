import { reactive, watch, toRaw } from 'vue';
import type { Reactive } from 'vue';

export class Row {
  // These are populated for each type of Row the first time its
  // `all()` is called, based on `rawTables` content.
  private static _map: Reactive<Map<number, Row>>;
  private static _all: Reactive<Row[]>;
  private static _maxId = 0;

  /**
   * Can be assigned manually, or generated by `create` or `insert`.
   */
  public id: number | undefined;

  /**
   * Retrieve the reactive list of all objects of the type of this subclass.
   * This should not be called on `Row` but on a subclass.
   * The returned value is cached, so the same object will always be returned.
   * @returns The reactive list of objects.
   */
  static all<RT extends typeof Row>(this: RT): Reactive<InstanceType<RT>[]> {
    // If we did this before for this type of Row, we'll just return
    // the reactive object.
    if (!this._all) {
      const map: Map<number, InstanceType<RT>> = new Map();
      const all = JSON.parse(
        localStorage.getItem('tcdb-' + this.name) || '[]',
      ).map((rowData: object) =>
        Object.assign(Object.create(this.prototype), rowData),
      );
      for (const obj of all) {
        this._maxId = Math.max(this._maxId, obj.id);
        map.set(obj.id, obj);
      }

      this._map = reactive(map);
      this._all = reactive(all);

      const syncAll = () => {
        const values = Array.from(this._map.values());
        localStorage.setItem('tcdb-' + this.name, JSON.stringify(values));
        let index = 0;
        for (const rowData of values) {
          this._maxId = Math.max(this._maxId, rowData.id || 0);
          this._all[index++] = rowData;
        }
        if (index < this._all.length) {
          this._all.splice(index, this._all.length - index);
        }
      }
      syncAll();
      // We're starting the watch in a setTimeout, to prevent auto-cleanup by
      // Vue in case this function was called synchronously within a component setup.
      setTimeout(() => {
        watch(this._map, syncAll, {deep: true, immediate: true});
      }, 0);
    }
    return this._all as Reactive<InstanceType<RT>[]>;
  }

  /**
   * Reactively retrieve a row from the store by its id. This should
   * not be called on `Row` but on a subclass.
   * @param id The id for the row tro retrieve.
   * @returns The row object. Or throws a `RangeError` if it does not exist.
   */
  static get<RT extends typeof Row>(this: RT, id: number): InstanceType<RT> {
    this.all(); // Make sure data is initialized.
    const result = this._map.get(id);
    if (!result) throw new RangeError(`${this.name}:${id} not found`);
    return result as InstanceType<RT>;
  }

  /**
   * Create a new row for a certain type, and optionally add it to the storage. This should
   * not be called on `Row` but on a subclass.
   * @param data An object containing any properties to set for the newly created row.
   * @param insert When `true` (the default), the newly created row is added to the storage.
   * @returns The newly created row, including default values. If `insert` is `true`,
   * it will also include a generated `id` and it will be a reactive object, as it is
   * included in `all`.
   */
  static create<RT extends typeof Row>(
    this: RT,
    data: Partial<InstanceType<RT>> = {},
    insert: boolean = true,
  ): InstanceType<RT> {
    const obj = Object.assign(new this(), data) as InstanceType<RT>;
    return insert ? obj.insert() : obj;
  }

  /**
   * Delete this row from the store.
   */
  public delete() {
    if (!this.id) throw new Error('delete() called but id was not set');
    const Class = this.constructor as typeof Row;
    Class.all(); // Make sure data is initialized.
    Class._map.delete(this.id);
  }

  /**
   * If the object has no `id` yet, assign one. Use this `id` to insert it into
   * the `all` object (causing persistence to localStorage).
   * If an `id` is provided, it may overwrite an existing row.
   * @param this The object to save.
   * @returns The reactive version of the object, as it is within `all`.
   */
  insert<T extends Row>(this: T): T {
    const Class = this.constructor as typeof Row;
    Class.all(); // Make sure data is initialized.
    if (!this.id) this.id = ++Class._maxId;
    Class._map.set(this.id, this);
    return Class._map.get(this.id) as T;
  }

  /**
   * Useful to create a temporary working copy that is not included in the store.
   * If desired, the copy can later be persisted by calling `insert` on it.
   * @returns A (non-reactive) deep copy of the object.
   */
  clone<T extends Row>(this: T): T {
    return Object.assign(
      Object.create(this.constructor.prototype),
      toRaw(this),
    );
  }

  public toString() {
    return `${this.constructor.name}:${this.id}`;
  }
}
